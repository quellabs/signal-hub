<?php
	
	namespace Quellabs\SignalHub\Transport;
	
	/**
	 * This class takes the schema generated by SchemaGenerator and applies it to
	 * real signal arguments to produce the final data structure for transport.
	 * Extracts ALL properties defined in the schema regardless of visibility.
	 */
	class SchemaDataExtractor {
		
		/**
		 * Track processed objects to prevent infinite recursion
		 * @var array
		 */
		private array $processingStack = [];
		
		/**
		 * Extract data from signal arguments using the provided schema
		 * @param array $args The actual arguments passed to signal->emit()
		 * @param array $schema The schema generated by SchemaGenerator
		 * @return array Data structure matching the schema with actual values
		 * @throws \RuntimeException
		 */
		public function extract(array $args, array $schema): array {
			// Reset processed objects for each new extraction
			$this->processingStack = [];
			
			// Start the extraction process
			$result = [];
			
			foreach ($schema as $paramIndex => $paramSchema) {
				// Skip if argument doesn't exist at this index
				if (!isset($args[$paramIndex])) {
					continue;
				}
				
				// Check if this parameter represents an object (schema is array)
				// Objects have their properties defined as nested arrays in schema
				if (is_array($paramSchema)) {
					// Extract object properties using schema-guided serialization
					$result[$paramIndex] = $this->serializeObjectRecursive($args[$paramIndex], $paramSchema);
					continue;
				}
				
				// This parameter is a primitive type - store value directly
				// using the parameter index as the key
				$result[$paramIndex] = $args[$paramIndex];
			}
			
			return $result;
		}
		
		/**
		 * Extract a specific property value from an object
		 * Uses reflection to access ANY property regardless of visibility
		 * @param object $obj The object to extract from
		 * @param string $propertyName Name of the property to extract
		 * @return mixed The property value or null if not accessible
		 */
		private function extractPropertyValue(object $obj, string $propertyName): mixed {
			try {
				// Check if the property exists on the object
				if (property_exists($obj, $propertyName)) {
					// Use reflection to access property metadata
					$reflection = new \ReflectionProperty($obj, $propertyName);
					
					// CRITICAL: Make property accessible regardless of visibility
					// This allows us to extract private/protected properties
					$reflection->setAccessible(true);
					
					// Extract the property value
					return $reflection->getValue($obj);
				}
			} catch (\ReflectionException $e) {
				// Property access failed (e.g., property doesn't exist, access denied)
				$className = get_class($obj);
				throw new \RuntimeException("Couldn't extract property {$className}::{$propertyName}: {$e->getMessage()}");
			}
			
			return null;
		}
		
		/**
		 * Recursive object serialization using schema
		 * @param object $object Object to serialize
		 * @param array $schema Schema to guide extraction
		 * @return array Serialized object data
		 * @throws \RuntimeException
		 */
		private function serializeObjectRecursive(object $object, array $schema): array {
			try {
				// Prevent infinite recursion by tracking processed objects
				if (in_array(spl_object_id($object), $this->processingStack)) {
					throw new \InvalidArgumentException("Circular reference detected for class: " . get_class($object));
				}
				
				// Mark this object as being processed
				$this->processingStack[] = spl_object_id($object);
				
				// Use schema to guide extraction
				$result = [];
				
				foreach ($schema as $propertyName => $propertySchema) {
					// Extract the property value
					$value = $this->extractPropertyValue($object, $propertyName);
					
					// If the property schema is an array, it's a nested object
					if (is_array($propertySchema)) {
						$result[$propertyName] = $this->serializeObjectRecursive($value, $propertySchema);
					} else {
						$result[$propertyName] = $value;
					}
				}
				
				// Return the result
				return $result;
			} catch (\ReflectionException $e) {
				throw new \RuntimeException("Unable to serialize class " . get_class($object) . ": {$e->getMessage()}");
			} finally {
				// Remove this object from the processed list after processing
				array_pop($this->processingStack);
			}
		}
	}