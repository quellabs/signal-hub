<?php
	
	namespace Quellabs\SignalHub\Transport;
	
	/**
	 * This class takes the schema generated by SchemaGenerator and applies it to
	 * real signal arguments to produce the final data structure for transport.
	 * Extracts ALL properties defined in the schema regardless of visibility.
	 */
	class SchemaDataExtractor {
		
		/**
		 * Track processed objects to prevent infinite recursion
		 * @var array
		 */
		private array $processedObjects = [];
		
		/**
		 * Extract data from signal arguments using the provided schema
		 * @param array $args The actual arguments passed to signal->emit()
		 * @param array $schema The schema generated by SchemaGenerator
		 * @return array Data structure matching the schema with actual values
		 */
		public function extract(array $args, array $schema): array {
			// Reset processed objects for each new extraction
			$this->processedObjects = [];
			
			// Start the extraction process
			$result = [];
			
			foreach ($schema as $paramIndex => $paramSchema) {
				// Skip if argument doesn't exist at this index
				if (!isset($args[$paramIndex])) {
					continue;
				}
				
				// Check if this parameter represents an object (schema is array)
				// Objects have their properties defined as nested arrays in schema
				if (is_array($paramSchema)) {
					// Extract object properties using schema-guided serialization
					$result = array_merge($result, $this->serializeObjectRecursive($args[$paramIndex], $paramSchema));
					continue;
				}
				
				// This parameter is a primitive type - store value directly
				// using the parameter index as the key
				$result[$paramIndex] = $args[$paramIndex];
			}
			
			return $result;
		}
		
		/**
		 * Extract a specific property value from an object
		 * Uses reflection to access ANY property regardless of visibility
		 * @param object $obj The object to extract from
		 * @param string $propertyName Name of the property to extract
		 * @return mixed The property value or null if not accessible
		 */
		private function extractPropertyValue(object $obj, string $propertyName): mixed {
			try {
				// Check if the property exists on the object
				if (property_exists($obj, $propertyName)) {
					// Use reflection to access property metadata
					$reflection = new \ReflectionProperty($obj, $propertyName);
					
					// CRITICAL: Make property accessible regardless of visibility
					// This allows us to extract private/protected properties
					$reflection->setAccessible(true);
					
					// Extract the property value
					return $reflection->getValue($obj);
				}
			} catch (\ReflectionException $e) {
				// Property access failed (e.g., property doesn't exist, access denied)
				// Return null to indicate extraction failure
			}
			
			return null;
		}
		
		/**
		 * Recursive object serialization using schema
		 * @param object $obj Object to serialize
		 * @param array $schema Schema to guide extraction
		 * @return array Serialized object data
		 */
		private function serializeObjectRecursive(object $obj, array $schema): array {
			// Prevent infinite recursion by tracking processed objects
			if (in_array(spl_object_id($obj), $this->processedObjects)) {
				return ['_circular_reference' => get_class($obj)];
			}
			
			// Mark this object as being processed
			$this->processedObjects[] = spl_object_id($obj);
			
			// Use schema to guide extraction
			$result = [];
			
			foreach ($schema as $propertyName => $propertySchema) {
				// Skip error indicators and circular references
				if (in_array($propertyName, ['_error', '_circular_reference'])) {
					continue;
				}
				
				// Extract the property value
				$value = $this->extractPropertyValue($obj, $propertyName);
				
				if ($value !== null) {
					// If the property schema is an array, it's a nested object
					if (is_array($propertySchema)) {
						$result[$propertyName] = $this->serializeObjectRecursive($value, $propertySchema);
					} else {
						$result[$propertyName] = $value;
					}
				}
			}
			
			// Remove this object from processed list after processing
			$this->processedObjects = array_filter($this->processedObjects, fn($id) => $id !== spl_object_id($obj));
			
			// Return the result
			return $result;
		}
	}